{"ast":null,"code":"// objects and functions for formatting diffs with partial context.  see the 'makeHunks()' documentation, below\n// for details.\n\n'use strict';\n\nfunction calcLen(linechanges, ab) {\n  let len = 0;\n  for (let ci = 0; ci < linechanges.length; ci++) {\n    switch (linechanges[ci].type) {\n      case REMOVED:\n        len += ab[0];\n        break;\n      case ADDED:\n        len += ab[1];\n        break;\n      case UNMODIFIED:\n        len++;\n        break;\n      default:\n        throw Error('unknown change type: ' + linechanges[ci].type);\n    }\n  }\n  return len;\n}\nfunction Hunk(aoff, boff, changes) {\n  this.changes = changes;\n  this.aoff = aoff;\n  this.boff = boff;\n  this._alen = -1;\n  this._blen = -1;\n}\nObject.defineProperty(Hunk.prototype, 'alen', {\n  get: function () {\n    return this._alen === -1 ? this._alen = calcLen(this.changes, [1, 0]) : this._alen;\n  }\n});\nObject.defineProperty(Hunk.prototype, 'blen', {\n  get: function () {\n    return this._blen === -1 ? this._blen = calcLen(this.changes, [0, 1]) : this._blen;\n  }\n});\nHunk.prototype.unified = function () {\n  let ret = [this.unifiedHeader()];\n  this.changes.forEach(function (c) {\n    ret.push(c.unified());\n  });\n  // console.log(\"expect:\\n'\" + ret.join(\"'\\n'\") + \"'\")   // useful for creating test output\n  return ret.join('\\n');\n};\nHunk.prototype.unifiedHeader = function () {\n  let alen = this.alen === 1 ? '' : ',' + this.alen;\n  let blen = this.blen === 1 ? '' : ',' + this.blen;\n  // empty hunks show zeroith line (prior).  hunks with lines show first line number\n  let afudg = this.alen === 0 ? 0 : 1;\n  let bfudg = this.blen === 0 ? 0 : 1;\n  return '@@ -' + (this.aoff + afudg) + alen + ' +' + (this.boff + bfudg) + blen + ' @@';\n};\nHunk.prototype.shorthand = function () {\n  return this.changes.reduce(function (s, c) {\n    return s + c.type;\n  }, '');\n};\nHunk.prototype.toString = function () {\n  return \"{\" + this.shorthand() + \"} \" + this.unifiedHeader();\n};\nconst ADDED = '+';\nconst REMOVED = '-';\nconst UNMODIFIED = 's';\nfunction type2unified(type) {\n  return type === 's' ? ' ' : type;\n}\n\n// LineChange objects represent a single line of change.  Converting diff.diffLine() result array into LineChange\n// object array:\n//\n//    1.  simplifies logic that needs work with lines\n//    2.  separates this extension module from specific dependency on the diff library\nfunction LineChange(type, text) {\n  this.type = type; // ADDED, REMOVED, UNMODIFIED\n  this.text = text;\n}\nLineChange.prototype.unified = function () {\n  return type2unified(this.type) + this.text;\n};\nLineChange.prototype.toString = function () {\n  return this.unified();\n};\n\n// convert a single change from diff.diffLines() into a single line string\n// (handy for debugging)\nfunction change2string(c, maxwidth) {\n  maxwidth = maxwidth || 60;\n  let ret = c.count + ': ' + type2unified(c.type);\n  let lim = Math.min(maxwidth - ret.length, c.value.length - 1); // remove last newline\n  let txt = c.value.substring(0, lim).replace(/\\n/g, ',') + (c.value.length > lim + 1 ? '...' : '');\n  return ret + txt;\n}\n\n// Convert a change as returned from diff.diffLines() into an LineChange objects with offset information.\n//\n//     change    - object returned from diff.diffLines() containing one or more lines of change info\n//     select    - (int)\n//                  positive, return up to this many lines from the start of change.\n//                  negative, return up to this many lines from the end of the change.\n//                  zero, return empty array\n//                  undefined, return all lines\n//\nfunction lineChanges(change, select) {\n  // debug:\n  // console.log(change2str(change) + (select === undefined ? '' : '  (select:' + select + ')'))\n  if (select === 0) {\n    return [];\n  }\n  let lines = [];\n  let v = change.value;\n  if (select === undefined) {\n    lines = v.split('\\n');\n    if (!lines[lines.length - 1]) {\n      lines.pop();\n    } // remove terminating new line\n  } else if (select > 0) {\n    let i = nthIndexOf(v, '\\n', 0, select, false);\n    lines = v.substring(0, i).split('\\n');\n  } else {\n    let len = v[v.length - 1] === '\\n' ? v.length - 1 : v.length;\n    let i = nthIndexOf(v, '\\n', len - 1, -select, true);\n    lines = v.substring(i + 1, len).split('\\n');\n  }\n  return lines.map(function (line) {\n    return new LineChange(change.type, line);\n  });\n}\n\n// convert a list of changes into a shorthand notation like 'ss--+++ss-+ss'\nfunction changes2shorthand(changes) {\n  return '{' + changes.reduce(function (s, c) {\n    for (let i = 0; i < c.count; i++) s += c.type;\n    return s;\n  }, '') + '}';\n}\n\n// concat-in-place, a -> b and return b\nfunction concatTo(a, b) {\n  Array.prototype.push.apply(b, a);\n  return b;\n}\n\n// Make Hunk objects from changes as returned from a call to unidiff.lineChanges().  Hunks are collections\n// of continuous line changes, therefore every hunk after the first marks a gap\n// where unmodified context lines are skipped.\n//\n//      let 's' represent an unmodifed line 'same'\n//          '-' represent a removed line\n//          '+' represent an added line\n//\n//      then hunks with a context of 2 could might like this:\n//\n//             hunk                hunk         hunk\n//           ___|____            ___|__        ___|___\n//          |        |          |       |     |       |\n//       sssss----++ssssssssssssss-ss--sssssssss+++++ssssssssss\n//\n//      or this:\n//\n//             hunk              hunk             hunk\n//           ___|____       ______|_______     ____|___\n//          |        |     |              |   |        |\n//          ++++++++sssssssss+++ssss---++sssssss--++++++\n//\n//      notice that with a context of 2, series of 4 or fewer unmodified lines are included in the same hunk.\n//\n// basic algo with context of 3, for illustration:\n//\n//     0. loop (over each block change)\n//        modified block:\n//           add all modified lines, continue loop 0\n//\n//        unmodified block:\n//           first hunk: collect tail portion, continue\n//           subsequent hunks: get head portion, and tail (iff there are more changes)\n//              head + tail <= 6 ?\n//                 add all to current hunk, continue loop 0\n//              head + tail > 6 ?\n//                 finish hunk with head portion\n//                 start new hunk with tail portion (iff there are more changes), continue loop 0\n//\nfunction makeHunks(changes, precontext, postcontext) {\n  //console.log('--------\\nmakeHunks(' + [changes2shorthand(changes), precontext, postcontext].join(', ') + ')')\n  let ret = []; // completed hunks to return\n  let lchanges = []; // accumulated line changes (continous/no-gap) to put into next hunk\n  let lskipped = 0; // skipped context to take into account in next hunk line numbers\n  function finishHunk() {\n    if (lchanges.length) {\n      let aoff = lskipped,\n        boff = lskipped;\n      if (ret.length) {\n        let prev = ret[ret.length - 1];\n        aoff += prev.aoff + prev.alen;\n        boff += prev.boff + prev.blen;\n      }\n      // add hunk and reset state\n      ret.push(new Hunk(aoff, boff, lchanges));\n      lchanges = [];\n      lskipped = 0;\n    }\n    // else keep state (lskipped) and continue\n  }\n  for (let ci = 0; ci < changes.length; ci++) {\n    let change = changes[ci];\n    if (change.type === UNMODIFIED) {\n      // add context\n      let ctx_after = ci > 0 ? postcontext : 0; // context lines following previous change\n      let ctx_before = ci < changes.length - 1 ? precontext : 0; // context lines preceding next change (iff there are more changes)\n      let skip = Math.max(change.count - (ctx_after + ctx_before), 0);\n      if (skip > 0) {\n        concatTo(lineChanges(change, ctx_after), lchanges); // finish up previous hunk\n        finishHunk();\n        concatTo(lineChanges(change, -ctx_before), lchanges);\n        lskipped = skip; // remember skipped for next hunk\n      } else {\n        concatTo(lineChanges(change), lchanges); // add all context\n      }\n    } else {\n      concatTo(lineChanges(change), lchanges); // add all modifications\n    }\n  }\n  finishHunk();\n  //console.log(ret.map(function(h){ return h.toString() }).join('\\n'))\n  return ret;\n}\n\n// no safty checks. caller knows that there are at least n occurances of v in s to be found.\n// reverse will search from high to low using lastIndexOf().\nfunction nthIndexOf(s, v, from, n, reverse) {\n  let d = reverse ? -1 : 1;\n  from -= d;\n  for (let c = 0; c < n; c++) {\n    from = reverse ? s.lastIndexOf(v, from + d) : s.indexOf(v, from + d);\n  }\n  return from;\n}\n\n// for testing and debugging\nexports.hunk = function (aoff, boff, lchanges) {\n  return new Hunk(aoff, boff, lchanges);\n};\nexports.linechange = function (type, text) {\n  return new LineChange(type, text);\n};\nexports.lineChanges = lineChanges;\nexports.change2string = change2string;\nexports.changes2shorthand = changes2shorthand;\nexports.nthIndexOf = nthIndexOf;\n\n// main API\nexports.makeHunks = makeHunks;\nexports.ADDED = ADDED;\nexports.REMOVED = REMOVED;\nexports.UNMODIFIED = UNMODIFIED;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}