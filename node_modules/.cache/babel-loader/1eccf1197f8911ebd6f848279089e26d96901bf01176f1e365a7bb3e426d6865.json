{"ast":null,"code":"'use strict';\n\nlet jdiff = require('diff');\nlet hunk = require('./hunk');\n\n// return a change type code for the change (returned from diff.diffLines())\nfunction changeType(change) {\n  if (change.added) {\n    return hunk.ADDED;\n  } else if (change.removed) {\n    return hunk.REMOVED;\n  } else {\n    return hunk.UNMODIFIED;\n  }\n}\n\n// Given changes from a call to diff.diffLines(), assign each change a type code and\n// check that no two of same type occur in a row\nfunction checkAndAssignTypes(changes) {\n  if (changes.length === 0) {\n    return [];\n  }\n  changes[0].type = changeType(changes[0]);\n  return changes.reduce(function (a, b, i) {\n    b.type = changeType(b);\n    if (a.type === b.type) {\n      throw Error('repeating change types are not handled: ' + a.type + ' (at ' + (i - 1) + ' and ' + i + ')');\n    }\n    return b;\n  });\n}\n\n// convert an array of results from diff.diffLines() into text in unified diff format.\n// return empty string if there are no changes.\nfunction formatLines(changes, opt) {\n  checkAndAssignTypes(changes);\n  opt = opt || {};\n  opt.aname = opt.aname || 'a';\n  opt.bname = opt.bname || 'b';\n  let context = opt.context || opt.context === 0 ? opt.context : 0;\n  opt.pre_context = opt.pre_context || opt.pre_context === 0 ? opt.pre_context : context;\n  opt.post_context = opt.post_context || opt.post_context === 0 ? opt.post_context : context;\n  let hunks = hunk.makeHunks(changes, opt.pre_context, opt.post_context);\n  if (hunks.length) {\n    let ret = [];\n    ret.push('--- ' + opt.aname);\n    ret.push('+++ ' + opt.bname);\n    hunks.forEach(function (h) {\n      ret.push(h.unified());\n    });\n    return ret.join('\\n');\n  } else {\n    return '';\n  }\n}\n\n// same as jsdiff.diffLines, but returns empty array when there are no changes (instead of an array with a single\n// unmodified change object)\nfunction diffLines(a, b, cb) {\n  a = Array.isArray(a) ? a.join('\\n') + '\\n' : a;\n  b = Array.isArray(b) ? b.join('\\n') + '\\n' : b;\n  let ret = jdiff.diffLines(a, b, cb);\n  if (ret.length === 1 && !ret[0].added && !ret[0].removed) {\n    return [];\n  } else {\n    return ret;\n  }\n}\nfunction diffAsText(a, b, opt) {\n  return formatLines(diffLines(a, b), opt);\n}\n\n// handy assertion function that asserts that two arrays or two multi-line strings are the same and reports\n// differences to console.log in unified format if there are differences.\n//\n//     actual - array or multi-line string to compare\n//     expected - array or multi-line string to compare\n//     label - label to clarify output if there are differences\n//     okFn - function like tape.ok that takes two arguments:\n//         expression - true if OK, false if failed test\n//         msg - a one-line message that prints upon failure\n//     logFn - function to call with diff output when there are differences (defaults to console.log)\n//\nfunction assertEqual(actual, expected, okFn, label, logFn) {\n  logFn = logFn || console.log;\n  okFn = okFn.ok || okFn;\n  let diff = diffAsText(actual, expected, {\n    context: 3,\n    aname: label + \" (actual)\",\n    bname: label + ' (expected)'\n  });\n  okFn(!diff, label);\n  if (diff) {\n    diff.split('\\n').forEach(function (line) {\n      logFn('  ' + line);\n    });\n  }\n}\nexports.assertEqual = assertEqual;\nexports.diffAsText = diffAsText;\nexports.formatLines = formatLines;\nexports.diffLines = diffLines;\nObject.keys(jdiff).forEach(function (k) {\n  if (!exports[k]) {\n    exports[k] = jdiff[k];\n  }\n});","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}